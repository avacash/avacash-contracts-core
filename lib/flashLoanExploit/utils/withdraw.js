const web3 = require('web3')
const crypto = require('crypto')
const snarkjs = require('snarkjs')
const circomlib = require('circomlib')
const buildGroth16 = require('websnark/src/groth16')
let groth16;
const websnarkUtils = require('websnark/src/utils')
const bigInt = snarkjs.bigInt
const fs = require('fs')

const provingKey = fs.readFileSync('/workspace/circuits/withdraw_proving_key.bin').buffer
const circuit = require('/workspace/circuits/withdraw.json')

const pedersenHash = (data) => circomlib.babyJub.unpackPoint(circomlib.pedersenHash.hash(data))[0]

function toHex(number, length = 32) {
  //console.log("number: ", number)
  const str = number instanceof Buffer ? number.toString('hex') : bigInt(number).toString(16)
  return '0x' + str.padStart(length * 2, '0')
}

function createDeposit({ nullifier, secret }) {
  const deposit = { nullifier: nullifier, secret: secret }
  deposit.preimage = Buffer.concat([deposit.nullifier.leInt2Buff(31), deposit.secret.leInt2Buff(31)])
  deposit.commitment = pedersenHash(deposit.preimage)
  deposit.commitmentHex = toHex(deposit.commitment)
  deposit.nullifierHash = pedersenHash(deposit.nullifier.leInt2Buff(31))
  deposit.nullifierHex = toHex(deposit.nullifierHash)
  return deposit;
}

function noteToDepositObject(noteString) {
  const noteRegex = /avacash-(?<currency>\w+)-(?<amount>[\d.]+)-(?<netId>\d+)-0x(?<note>[0-9a-fA-F]{124})/g
  const match = noteRegex.exec(noteString)
  if (!match) {
    console.error("Note in Invalid Format")
  }

  const buf = Buffer.from(match.groups.note, 'hex')
  const nullifier = bigInt.leBuff2int(buf.slice(0, 31))
  const secret = bigInt.leBuff2int(buf.slice(31, 62))

  return createDeposit({ nullifier, secret })
}

async function generateProof({ foundDeposit,
                              recipient,
                              relayerAddress = '0',
                              fee = web3.utils.toWei('0', 'ether'),
                              refund = 0 }) {

  const groth16 = await buildGroth16()
  const { root, path_elements, path_index } = await foundDeposit.tree_path
  // Prepare circuit input

  const input = {
    // Public snark inputs
    root: root,
    nullifierHash: foundDeposit.nullifierHash,
    recipient: bigInt(recipient),
    relayer: bigInt(relayerAddress),
    fee: bigInt(fee.toString()),
    refund: bigInt(refund),

    // Private snark inputs
    nullifier: foundDeposit.nullifier,
    secret: foundDeposit.secret,
    pathElements: path_elements,
    pathIndices: path_index
  }
  
  const proofData = await websnarkUtils.genWitnessAndProve(groth16, input, circuit, provingKey)
  const { proof } = websnarkUtils.toSolidityInput(proofData)

  const args = [
    toHex(input.root),
    toHex(input.nullifierHash),
    toHex(input.recipient, 20),
    toHex(input.relayer, 20),
    toHex(input.fee),
    toHex(input.refund)
  ]

  return { proof, args }
}


module.exports = {
  generateProof,
  noteToDepositObject,
}
