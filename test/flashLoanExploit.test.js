/* global artifacts, web3, contract */
require('chai')
  .use(require('bn-chai')(web3.utils.BN))
  .use(require('chai-as-promised'))
  .should()
const fs = require('fs')
const {
  noteToDepositObject,
  generateProof
} = require('../lib/flashLoanExploit/utils/withdraw')
const {getNoteString, generateDeposit} = require('../lib/flashLoanExploit/utils/deposit')



var BN = web3.utils.BN;
const { toBN, randomHex } = require('web3-utils')
const BigNumber = require('bignumber.js');
const { takeSnapshot, revertSnapshot } = require('../lib/ganacheHelper')

const Tornado = artifacts.require('./AvacashFinance_AVAX.sol')
const {MERKLE_TREE_HEIGHT } = process.env

const websnarkUtils = require('websnark/src/utils')
const buildGroth16 = require('websnark/src/groth16')
const stringifyBigInts = require('websnark/tools/stringifybigint').stringifyBigInts
const unstringifyBigInts2 = require('snarkjs/src/stringifybigint').unstringifyBigInts
const snarkjs = require('snarkjs')
const bigInt = snarkjs.bigInt
const crypto = require('crypto')
const circomlib = require('circomlib')
const MerkleTree = require('../lib/MerkleTree')

const rbigint = (nbytes) => snarkjs.bigInt.leBuff2int(crypto.randomBytes(nbytes))
const pedersenHash = (data) => circomlib.babyJub.unpackPoint(circomlib.pedersenHash.hash(data))[0]
const toFixedHex = (number, length = 32) =>  '0x' + bigInt(number).toString(16).padStart(length * 2, '0')
const getRandomRecipient = () => rbigint(20)

// const {getNoteString, storeData} = require('../utils/deposit')

  // function generateDeposit() {
  //   let deposit = {
  //     secret: rbigint(31),
  //     nullifier: rbigint(31),
  //   }
  //   const preimage = Buffer.concat([deposit.nullifier.leInt2Buff(31), deposit.secret.leInt2Buff(31)])
  //   deposit.commitment = pedersenHash(preimage)
  //   return deposit
  // }

// eslint-disable-next-line no-unused-vars
function BNArrayToStringArray(array) {
  const arrayToPrint = []
  array.forEach(item => {
    arrayToPrint.push(item.toString())
  })
  return arrayToPrint
}

function snarkVerify(proof) {
  proof = unstringifyBigInts2(proof)
  const verification_key = unstringifyBigInts2(require('../build/circuits/withdraw_verification_key.json'))
  return snarkjs['groth'].isValid(verification_key, proof, proof.publicSignals)
}

contract('AvacashFinance_AVAX', accounts => {
  let tornado
  const sender = accounts[0]
  const relayer = accounts[1]
  const operator = accounts[2]
  const levels = 20 //MERKLE_TREE_HEIGHT || 16
  const value = '100000000000000000000' // The last deployed denomination was 100 ether
  let snapshotId
  let prefix = 'test'
  let tree
//  const fee = bigInt(ETH_AMOUNT).shr(1) || bigInt(1e17)
  const refund = bigInt(0)
  const recipient = getRandomRecipient()
  let groth16
  let circuit
  let proving_key

  // Flash loan test:
  const Borrower = artifacts.require('./test/Borrower.sol')
  const FlashLoanExploiter = artifacts.require('./test/FlashloanExploiter.sol')
  let borrower
  let fee
  let initialTornadoBalance
  let flashLoanFeeReceiver
  let initialFeeReceiverBalance
  let _recipient
  let _flashLoanProvider;

  let finalTornadoBalance
  let finalFeeReceiverBalance

  let commitment

  let result

  let deposit

  let instanceBalance

  let input

  let my_root, my_path_elements, my_path_index

  let _exploiter

  let nullifierHex

  before(async () => {
    tree = new MerkleTree(
      levels,
      null//,
      //prefix,
    )
    tornado = await Tornado.deployed()
    snapshotId = await takeSnapshot()
    groth16 = await buildGroth16()
    circuit = require('../build/circuits/withdraw.json')
    proving_key = fs.readFileSync('build/circuits/withdraw_proving_key.bin').buffer

    flashLoanFeeReceiver = await tornado.flashLoanFeeReceiver();
    _flashLoanProvider = tornado.address;

    fee = await tornado.flashLoanFee();
    assert.equal(fee, 3, 'Wrong flashLoanFee');

    deposit = generateDeposit()

  })

  let testNumber = 1;
  const commitment0 = toFixedHex(41)
  const commitment1 = toFixedHex(40)

  describe('#FlashLoanExploit as in December Tests:', () => {

    beforeEach(async () => {
      console.log("Test Number #", testNumber);
      testNumber ++;
    })

    it('ReentrancyGuard should prevent attack', async () => {

      // commitment = toFixedHex(41)
      await tornado.deposit(commitment0, { value: value, from: sender })
      // await tree.insert(commitment)

      // commitment = toFixedHex(40)
      await tornado.deposit(commitment1, { value: value, from: sender })
      // await tree.insert(commitment)

      borrower = await Borrower.deployed()
      await borrower.payableFunction({value: 10000000000000000000, from: accounts[4]});


      initialTornadoBalance = toBN(await web3.eth.getBalance(tornado.address));
    //  console.log("initialTornadoBalance: " , initialTornadoBalance.toString())
      initialFeeReceiverBalance= toBN(await web3.eth.getBalance(flashLoanFeeReceiver));
    //  console.log("initialFeeReceiverBalance: " , initialFeeReceiverBalance.toString())
      initialBorrowerBalance= toBN(await web3.eth.getBalance(borrower.address));


      // 1. Initializing contracts - Variables
      const flashLoanExploiter = await FlashLoanExploiter.deployed()
      const denomination = await tornado.denomination()
      console.log(" - Instance denomination:", web3.utils.fromWei(denomination), " AVAX")
      instanceBalance = await web3.eth.getBalance(tornado.address)
      console.log(" - Instance balance:", web3.utils.fromWei(instanceBalance), " AVAX")

      // 2. Initializing exploit variables
      const _provider = tornado.address
      _exploiter = accounts[9]
      const _exploitAmount = denomination
      console.log(" - _exploitAmount:", web3.utils.fromWei(_exploitAmount), " AVAX")

      // 3. Funding the flashLoanExploiter before using it
      let flashLoanFee = await tornado.flashLoanFee()
      console.log(" - flashLoanFee:", flashLoanFee.toString())
      let feeAdjusted = flashLoanFee.mul(_exploitAmount)
      console.log(" - feeAdjusted:", feeAdjusted.toString())
      let fee = feeAdjusted.div(web3.utils.toBN(10000))
      console.log(" - fee:", web3.utils.fromWei(fee), " AVAX")
      console.log(" -- ")
      console.log(" -- ")
      console.log(" - Funding the Exploiter with fee")
      await flashLoanExploiter.payableFunction({value: fee, from: accounts[0]});
      console.log ("  - current flashLoanExploiter balance ", web3.utils.fromWei( await web3.eth.getBalance(flashLoanExploiter.address)), " AVAX")

      // 4. Precalculate _data (which is the commitment.)

      const _exploitData = web3.utils.toHex(deposit.commitment.toString())

      // 5. Exploit (ask for flashloan and deposit)


      const exploitResponse = await flashLoanExploiter.exploit(
          _provider,
          flashLoanExploiter.address,
          _exploitAmount,
          _exploitData, {from: _exploiter}).should.be.rejected

        exploitResponse.reason.should.be.equal("ReentrancyGuard: reentrant call")

        })
      it('Checking same InstanceBalance', async () => {

        // 6. Thief (tries to ) Withdraws deposit using Instance
        const newInstanceBalance = await web3.eth.getBalance(tornado.address)
        console.log(" - newInstanceBalance:", web3.utils.fromWei(newInstanceBalance), " AVAX")

        assert.equal(newInstanceBalance,instanceBalance, 'The instance should keep the same amount of AVAX');
      })
      it('Checking Commitments', async () => {
        // check that commitments[deposit.commitment] = false
        //console.log("Tornado:", tornado)
        let commitmentExist = await tornado.commitments(toFixedHex(deposit.commitment))
        console.log(" - commitmentExist:", commitmentExist)


        assert.equal(commitmentExist,false, 'Commitment should not exist as the deposit should not have happened');

      })

      it('Checking Root', async () => {

        // 7. Prepares everything for withdrawal
        await tree.insert(commitment0)
        await tree.insert(commitment1)
        await tree.insert(deposit.commitment)
        const { root, path_elements, path_index } = await tree.path(2)
        my_root = root;
        my_path_elements = path_elements;
        my_path_index = path_index;

        const isValidRoot = await  tornado.isKnownRoot(web3.utils.toHex(root))
        console.log ("  - isValidRoot : ", isValidRoot)

        assert.equal(isValidRoot,false, 'Root should not be valid as the deposit should not have happened');
      })

      it('Trying to Withdraw Deposit from Attack', async () => {

        const relayerFee = bigInt(0)
        console.log("relayerFee: ", web3.utils.fromWei(relayerFee.toString()), " AVAX")
        // const note = getNoteString(deposit, "AVAX", "100", 1337)
        // console.log("note :", note)
        // const depositObject = noteToDepositObject(note)

        input = stringifyBigInts({
            root: my_root,
            nullifierHash: pedersenHash(deposit.nullifier.leInt2Buff(31)),
            nullifier: deposit.nullifier,
            secret: deposit.secret,
            pathElements: my_path_elements,
            pathIndices: my_path_index,
            relayer: bigInt(relayer),
            recipient: bigInt(_exploiter),
            fee: relayerFee,
            refund: bigInt(0),
          })
        nullifierHex = toFixedHex(input.nullifierHash)
        const proofData = await websnarkUtils.genWitnessAndProve(groth16, input, circuit, proving_key)
        const { proof } = websnarkUtils.toSolidityInput(proofData)


        let isSpent = await tornado.isSpent(toFixedHex(input.nullifierHash))
        isSpent.should.be.equal(false)

        const args = [
          toFixedHex(input.root),
          toFixedHex(input.nullifierHash),
          toFixedHex(input.recipient, 20),
          toFixedHex(input.relayer, 20),
          toFixedHex(input.fee),
          toFixedHex(input.refund)
        ]

        //let  withdrawError = await tornado.withdraw(proof, ...args, { from: _exploiter })

        let  withdrawError = await tornado.withdraw(proof, ...args, { from: _exploiter }).should.be.rejected
        withdrawError.reason.should.be.equal("Cannot find your merkle root")
    })

    it('Veryfing that Deposit from Attack was not Withdrawn', async () => {

      // Should still be false
      let isSpent2 = await tornado.isSpent(nullifierHex)
      isSpent2.should.be.equal(false)

    })


  })


})
